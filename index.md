# Adrian CÄƒlÄƒvie

Drajna de Jos, Prahova, Romania

![github stats](https://github-readme-stats.vercel.app/api?username=adriancalavie)


## Summary

Hi! I am a student at Transilvania Univeristy of BraÈ™ov. I am interested in algorithms, data structures and AI. You can see some of my past projects on my github profile. I am currently residing in BraÈ™ov.

## Experience

* Intern at Siemens PLM Software
* Curious Minds Summer School Apprentice at Siemens PLM Software
* Spring School Apprentice at General Magic
* Apprentice at Endava

## Projects

#### ðŸ§©[Mosaic++](https://bitbucket.org/mosaic-pp/mosaic/src/master/)

Mosaic++ is a tool that produces [photomosaics](https://en.wikipedia.org/wiki/Photographic_mosaic). It offers a range of options that have an effect on the final
result. It can be used for entertainment purposes or be converted to an applicable tool in fields like image
processing or mesh generation.

This project started as a college assignment for a Modern C++ course I took.

#### ðŸ“ˆ[Plotting Project](https://github.com/Florin9925/Plotting-)

A plotting project made with Qt and QCustomPlot. The scope of the app is to generate graphs for various functions and to observe the steps taken by the
algorithm in order to obtain the correct plotting. 

#### ðŸ‡±ðŸ‡º[Luxembourg map traversal](https://github.com/adriancalavie/Luxembourg)

One of the homeworks at a Graph Theory course I took required us to compute the shortest path between
two points on the map of Luxembourg. We were given the input data as a massive xml file consisting of
nodes and edges and our task was to translate the latitude and longitude values into pixels on the screen,
to plot them and let the user choose two points on the map, the points to be chosen would be the closest to
where the mouse clicks. The homework also requested we implement both Dijkstra's and Bellam-Ford
algorithms.

####  ðŸ¤–[AI puzzle solver](https://github.com/adriancalavie/AI-puzzle)

This C++ code from 2019 solves the x-puzzle problem. I wrote it in my first year at University.
The algorithm uses states to verify if the current current puzzle is in final form or not. It firstly checks if the
game is resolvable or not based on the information on this [site](http://kevingong.com/Math/SixteenPuzzle.html).
If it is solveable, it searches for the best move set(the one with the lowest number of moves that reaches a final state) using A*.

